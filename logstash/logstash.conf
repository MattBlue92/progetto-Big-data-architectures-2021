input {
  jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => " select * from (select  host.host as hostname, host.ip as host_ip, host.dns as host_dns, host.port as host_port, docker_name.docker_name as docker_name, info.value as container, SUBSTRING_INDEX(SUBSTRING_INDEX(SUBSTRING_INDEX(SUBSTRING_INDEX(i.name, 'S', 2), 'S', -1), ':', 1), ':', -1) as instance_id, SUBSTRING_INDEX(SUBSTRING_INDEX(i.name, ':', 2), ':', -1) as metrics,   from_unixtime(h.clock) as time, h.value from items i, history h, (SELECT DISTINCT SUBSTRING_INDEX(SUBSTRING_INDEX(i.name, ':', 1), ':', -1) as name, h.value FROM items i, history_text h where h.itemid=i.itemid and SUBSTRING_INDEX(SUBSTRING_INDEX(i.name, ':', 2), ':', -1)=' MarathonAppId' and h.value != 'unknown') as info, (select h.hostid as hostid , h.host as host, id.ip as ip, id.dns as dns, id.port as port from hosts h, interface id  where h.hostid = id.hostid) as host, (select DISTINCT i.hostid as hostid, h.value as docker_name from items i, history_str h where i.itemid=h.itemid and i.name = 'Docker: Name') as docker_name where i.itemid=h.itemid and i.hostid =host.hostid and i.hostid =docker_name.hostid and i.name regexp '^(Container /mesos)' and SUBSTRING_INDEX(SUBSTRING_INDEX(i.name, ':', 1), ':', -1)=info.name union all select  host.host as hostname, host.ip as host_ip, host.dns as host_dns, host.port as host_port, docker_name.docker_name as docker_name, IF(SUBSTRING_INDEX(SUBSTRING_INDEX(SUBSTRING_INDEX(SUBSTRING_INDEX(i.name, 'S', 2), 'S', -1), ':', 1), ':', -1)='Docker','Docker',  info.value) as container, SUBSTRING_INDEX(SUBSTRING_INDEX(SUBSTRING_INDEX(SUBSTRING_INDEX(i.name, 'S', 2), 'S', -1), ':', 1), ':', -1) as instance_id, SUBSTRING_INDEX(SUBSTRING_INDEX(i.name, ':', 2), ':', -1) as metrics, from_unixtime(h.clock) as time, h.value from items i, history_uint h, (SELECT DISTINCT SUBSTRING_INDEX(SUBSTRING_INDEX(i.name, ':', 1), ':', -1) as name, h.value FROM items i, history_text h where h.itemid=i.itemid and SUBSTRING_INDEX(SUBSTRING_INDEX(i.name, ':', 2), ':', -1)=' MarathonAppId' and h.value != 'unknown') as info, (select h.hostid as hostid, h.host as host, id.ip as ip, id.dns as dns, id.port as port from hosts h, interface id  where h.hostid = id.hostid) as host, (select DISTINCT i.hostid as hostid, h.value as docker_name from items i, history_str h where i.itemid=h.itemid and i.name = 'Docker: Name') as docker_name where i.itemid=h.itemid and i.hostid =host.hostid and i.hostid =docker_name.hostid and (i.name = 'Docker: Containers paused' or  i.name ='Docker: Containers running' or i.name= 'Docker: Containers stopped' or i.name= 'Docker: Containers total'or (i.name regexp '^(Container /mesos)' and SUBSTRING_INDEX(SUBSTRING_INDEX(i.name, ':', 1), ':', -1)=info.name))) as query where (time > :sql_last_value AND time < NOW()) order by time asc "
        use_column_value => true
        tracking_column => time
    }
  }
output {
  stdout { codec => json_lines }
  elasticsearch {
    hosts => "elasticsearch:9200"
    index => "mysql-migrate"
    document_id => "%{container} %{metrics} %{time}"
    document_type => "zabbixdata"
  }
}
