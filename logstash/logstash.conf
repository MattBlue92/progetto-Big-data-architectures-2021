input { 
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Finished_at where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "finished_at"
        last_run_metadata_path => "/home/finished_at"  
    }
    
    
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Started_at where  (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "started_at"
        last_run_metadata_path => "/home/started_at"  
    }
    
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
        last_run_metadata_path => "/home/cpu_kernelmode_usage_per_second"  
    # our query
        statement => "select * from CPU_kernelmode_usage_per_second where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "cpu_kernelmode_usage_per_second"
        last_run_metadata_path => "/home/cpu_kernelmode_usage_per_second" 
    }
    
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Throttled_time where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "throttled_time"
        last_run_metadata_path => "/home/throttled_time" 
    }
    
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from CPU_total_usage_per_second where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "cpu_total_usage_per_second"
        last_run_metadata_path => "/home/cpu_total_usage_per_second"
    }
    
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from CPU_usermode_usage_per_second where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "cpu_usermode_usage_per_second"
        last_run_metadata_path => "/home/cpu_usermode_usage_per_second"
    }
    
   jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Networks_bytes_received_per_second where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "networks_bytes_received_per_second"
        last_run_metadata_path => "/home/networks_bytes_received_per_second"
    }
    
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Networks_incoming_packets_dropped_per_second where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "networks_incoming_packets_dropped_per_second"
        last_run_metadata_path => "/home/networks_incoming_packets_dropped_per_second"
    }
    
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Networks_errors_received_per_second where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "networks_errors_received_per_second"
        last_run_metadata_path => "/home/networks_errors_received_per_second"
    }
 
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Networks_packets_received_per_second where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "networks_packets_received_per_second"
        last_run_metadata_path => "/home/networks_packets_received_per_second"
    }
 
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Networks_bytes_sent_per_second where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "networks_bytes_sent_per_second"
        last_run_metadata_path => "/home/networks_bytes_sent_per_second"
    }
    
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Networks_outgoing_packets_dropped_per_second where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "networks_outgoing_packets_dropped_per_second"
        last_run_metadata_path => "/home/networks_outgoing_packets_dropped_per_second"
    }
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Networks_errors_sent_per_second where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "networks_errors_sent_per_second"
        last_run_metadata_path => "/home/networks_errors_sent_per_second"
    }
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Networks_packets_sent_per_second where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "networks_packets_sent_per_second"
        last_run_metadata_path => "/home/networks_packets_sent_per_second"
    }
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Memory_maximum_usage where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "memory_maximum_usage"
        last_run_metadata_path => "/home/memory_maximum_usage"
    }
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Restart_count where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "restart_count"
        last_run_metadata_path => "/home/restart_count"
    }
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Dead where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "dead"
        last_run_metadata_path => "/home/dead"
    }
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from OMKilled where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "omkilled"
        last_run_metadata_path => "/home/omkilled"
    }
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Paused where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "paused"
        last_run_metadata_path => "/home/paused"
    }
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Pid where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "pid"
        last_run_metadata_path => "/home/pid"
    }
     jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Running where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "running"
        last_run_metadata_path => "/home/running"
    }
      jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Throttled_periods where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "throttled_periods"
        last_run_metadata_path => "/home/throttled_periods"
    }
      jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Restarting where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "restarting"
        last_run_metadata_path => "/home/restarting"
    }
                                              
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Throttling_periods where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "throttling_periods"
        last_run_metadata_path => "/home/throttling_periods"   
    }
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Memory_commit_bytes where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "memory_commit_bytes"
        last_run_metadata_path => "/home/memory_commit_bytes"
    }
    
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Memory_commit_peak_bytes where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "memory_commit_peak_bytes"
        last_run_metadata_path => "/home/memory_commit_peak_bytes"
    }
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Memory_maximum_usage where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "memory_maximum_usage"
        last_run_metadata_path => "/home/memory_maximum_usage"
    }
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Memory_private_working_set where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "memory_private_working_set"
        last_run_metadata_path => "/home/memory_private_working_set"
    }
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Memory_usage where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "memory_usage"
        last_run_metadata_path => "/home/memory_usage"
    }
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Online_CPUs where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "online_cpus"
        last_run_metadata_path => "/home/online_cpus"
    }
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from Error where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "error"
        last_run_metadata_path => "/home/error"
    }
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from DockerPaused where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "dockerpaused"
        last_run_metadata_path => "/home/dockerpaused"
    }
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from DockerRunning where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "dockerrunning"
        last_run_metadata_path => "/home/dockerrunning"
    }
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from DockerStopped where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "dockerstopped"
        last_run_metadata_path => "/home/dockerstopped"
    }
    jdbc { 
        jdbc_driver_library => "${LOGSTASH_JDBC_DRIVER_JAR_LOCATION}"
        jdbc_driver_class => "${LOGSTASH_JDBC_DRIVER}"
        jdbc_connection_string => "${LOGSTASH_JDBC_URL}"
        jdbc_user => "${LOGSTASH_JDBC_USERNAME}"
        jdbc_password => "${LOGSTASH_JDBC_PASSWORD}"
        schedule => "* * * * *"
    # our query
        statement => "select * from DockerTotal where (time > :sql_last_value AND time < NOW()) order by time asc"
        tracking_column => time
        tracking_column_type => "timestamp"
        use_column_value => true
        type => "dockertotal"
        last_run_metadata_path => "/home/dockertotal"
    }
  }
  
  filter {
      mutate {
        convert => {
          "value" => "float"
           }
      }
    }
  
output {

   if[type] == "finished_at" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_finished_at"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "started_at" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_started_at"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "cpu_kernelmode_usage_per_second" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_cpu_kernelmode_usage_per_second"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "throttled_time" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_throttled_time"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "cpu_total_usage_per_second" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_cpu_total_usage_per_second"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "cpu_usermode_usage_per_second" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_cpu_usermode_usage_per_second"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "networks_bytes_received_per_second" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_networks_bytes_received_per_second"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "networks_incoming_packets_dropped_per_second" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_cpu_kernelmode_usage_per_second"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "networks_errors_received_per_second" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_networks_errors_received_per_second"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "networks_packets_received_per_second" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_networks_packets_received_per_second"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "networks_bytes_sent_per_second" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_networks_bytes_sent_per_second"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "networks_outgoing_packets_dropped_per_second" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_networks_outgoing_packets_dropped_per_second"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "networks_errors_sent_per_second" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_networks_errors_sent_per_second"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "networks_packets_sent_per_second" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_networks_packets_sent_per_second"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "memory_maximum_usage" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_memory_maximum_usage"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "restart_count" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_restart_count"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "dead" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_dead"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "omkilled" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_omkilled"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "paused" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_paused"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "pid" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_pid"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "running" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_running"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "throttled_periods" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_throttled_periods"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "restarting" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_restarting"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "throttling_periods" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_throttling_periods"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "memory_commit_bytes" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_memory_commit_bytes"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "memory_commit_peak_bytes" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_memory_commit_peak_bytes"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "memory_maximum_usage" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_memory_maximum_usage"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "memory_private_working_set" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_memory_private_working_set"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "memory_usage" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_memory_usage"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "online_cpus" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_online_cpus"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "error" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_error"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "dockerpaused" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_dockerpaused"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "dockerrunning" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_dockerrunning"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "dockerstopped" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_dockerstopped"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    if[type] == "dockertotal" {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "migrate_dockertotal"
            document_id => "%{container} %{metrics} %{time}"
        }
    }
    stdout {
        codec => json_lines
    }
 
}
